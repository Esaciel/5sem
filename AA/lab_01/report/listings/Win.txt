matrix_time multiply_Vinograd(Matrix& A, Matrix& B)
{
    size_t n = A.size();
    size_t q = A[0].size();
    size_t m = B[0].size();

    if (q != B.size()) throw Unmultipliable();

    clock_t time;

    time = clock();

    Matrix C = createMatrix(n, m);
    vector<number> mul_v = createVector(m);
    vector<number> mul_h = createVector(n);

    for (size_t i = 0; i < n; ++i)
    {
        for (size_t k = 0; k < (q / 2); ++k)
        {
            mul_h[i] += A[i][2*k] * A[i][2*k + 1];
        }
    }

    for (size_t j = 0; j < m; ++j)
    {
        for (size_t k = 0; k < (q / 2); ++k)
        {
            mul_v[j] += B[2*k][j] * B[2*k + 1][j];
        }
    }

    for (size_t i = 0; i < n; ++i)
    {
        for (size_t j = 0; j < m; ++j)
        {
            C[i][j] -= mul_h[i] + mul_v[j];

            for (size_t k = 0; k < (q / 2); ++k)
            {
                C[i][j] += (A[i][2*k] + B[2*k + 1][j]) * (A[i][2*k + 1] + B[2*k][j]);
            }

            if (q % 2 == 1)
                C[i][j] += A[i][q-1] * B[q-1][j];

        }
    }

    time = clock() - time;

    return {C, time};
}